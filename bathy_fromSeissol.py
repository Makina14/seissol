import csv
#import matplotlib.pyplot as plt
#from matplotlib import path
#from scipy.spatial import ConvexHull
#from scipy.interpolate import griddata
#import cv2
import itertools
import time
import os

from netCDF4 import Dataset
import numpy as np
from datetime import datetime
import seissolxdmf
import trimesh
import trimesh.proximity
import trimesh.ray
from pyembree import rtcore_scene


def grdwrite(x, y, z, foutput):
    today = datetime.today()
    #Definimos el dataset y definimos las dimensiones
    dataset = Dataset(foutput, 'w', format="NETCDF4")
    dataset.createDimension('x', len(x))
    dataset.createDimension('y', len(y))

    #Creamos las variables del dataset
    longitud = dataset.createVariable('x', 'f8', 'x')
    latitud = dataset.createVariable('y', 'f8', 'y')
    valores_interpolados = dataset.createVariable('z', 'f4', ('y', 'x'))

    #Añadimos los datos a las variables creadas
    longitud[:] = x
    latitud[:] = y
    valores_interpolados[:, :] = z

    #Añadimos informacion general del dataset
    dataset.Conventions = " "
    dataset.title = foutput
    dataset.history = "File written using netCDF4 Python module"
    dataset.description = "Created " + today.strftime("%d/%m/%y")
    dataset.GMT_version = "6.1.0"
    longitud.units = "degrees east"
    latitud.units = "degrees north"
    valores_interpolados.units = 'meters'

    dataset.close()

    return


def getBarycentricCoord(pto, vert_a, vert_b, vert_c):
    """
    Function returning a list of the barycentric coordinates of a 2D point within a 2D triangle

    :param pto: point within the trinagle
    :param vert_a: vertex a
    :param vert_b: vertex b
    :param vert_c: vertex c
    :return: list of the three barycentric coordinates of pto respecto to vertex a, vertex b and vertex c
    """
    ab = vert_b-vert_a
    ac = vert_c-vert_a
    ap = pto-vert_a

    normal_ac = [vert_a[1] - vert_c[1], vert_c[0] - vert_a[0]]
    normal_ab = [vert_a[1] - vert_b[1], vert_b[0] - vert_a[0]]

    bary_beta = np.dot(ap, normal_ac)/np.dot(ab, normal_ac)
    bary_gamma = np.dot(ap, normal_ab)/np.dot(ac, normal_ab)
    bary_alpha = 1.000 - bary_beta - bary_gamma

    return [bary_alpha, bary_beta, bary_gamma]


def generateMesh3DfromSeissol(path2SeissolOutput):
    """
    Return a trimesh object generated using SeisSol nodes and connectivity arrays

    :param path2SeissolOutput:  path to the file .xdmf generated by SeisSol. Same folder must contain
                                the files of the vertex and cell information
    :return: trimesh 3d object
    """
    sx = seissolxdmf.seissolxdmf(path2SeissolOutput)
    nodes_seissol3d = sx.ReadGeometry()     # nodes array
    faces_seissol3d = sx.ReadConnect()      # connectivity array
    mesh3d = trimesh.Trimesh(vertices=nodes_seissol3d,
                             faces=faces_seissol3d)  # trimesh object
    return mesh3d


def generateMesh2DfromSeissol(path2SeissolOutput):
    """
    Return a trimesh object generated using SeisSol nodes and connectivity arrays. It is projected to z=0.

    :param path2SeissolOutput:  path to the file .xdmf generated by SeisSol. Same folder must contain
                                the files of the vertex and cell information
    :return: trimesh 2d-essentially object in the sense that nodes vertical component is 0
    """
    sx = seissolxdmf.seissolxdmf(path2SeissolOutput)
    nodes_seissol3d = sx.ReadGeometry()     # nodes array
    faces_seissol3d = sx.ReadConnect()      # connectivity array
    N_nodes = len(nodes_seissol3d)

    nodos_seissol2d = np.delete(nodes_seissol3d, 2, 1)     # remove last component
    nodos_seissol2d = np.c_[nodos_seissol2d, np.zeros(N_nodes)]     # add z=0 to each node to keep working on 3D

    mesh2d = trimesh.Trimesh(vertices=nodos_seissol2d, faces=faces_seissol3d)
    return mesh2d


def assign_nodes_values(path2SeissolOutput, variable, instant, outputfile=None):
    """
    This function assigns values to the nodes of a 3D triangular mesh based on a weighted mean using
    the faces areas that contain each node as a vertex

    :param path2SeissolOutput: path to the file .xdmf generated by SeisSol. Same folder must contain
                        the files of the vertex and cell information
    :param variable: string name of one of the variables provided by SeisSol
    :param instant: timestep of the SeisSol output
    :param outputfile: path and name of the output file where the final nodes values are saved. If not provided
                the name will be "node_values_[variable]_timestep[instant]" and will be saved on the current directory
    :return: .npy file of the assigned values to the nodes
    """
    sx = seissolxdmf.seissolxdmf(path2SeissolOutput)    # open the SeisSol output to read the variable
    values = sx.ReadData(variable)  # read the variable
    mesh3d = generateMesh3DfromSeissol(path2SeissolOutput)  # generate the trimesh object
    area_triangles = mesh3d.area_faces
    nodes_value = []
    for i in range(0, len(mesh3d.vertices)):
        shared_faces = mesh3d.vertex_faces[i]    #indices de caras que tienen al nodo_i en comun
        shared_faces = np.delete(shared_faces, np.where(shared_faces == -1))  #quitamos los indices -1
        total_shared_area = 0.0
        value_acum = 0.0
        for j in range(0, len(shared_faces)):
            area_j = area_triangles[shared_faces[j]]    #area de triangulo adyacente
            v_j = values[instant][shared_faces[j]] #valor de la variable en el instante elegido y en el triangulo
            value_acum += v_j * area_j
            total_shared_area += area_j
        final_node_value = value_acum / total_shared_area   #valor final que asociamos al nodo tras la ponderacion
        nodes_value.append(final_node_value)
    nodes_value = np.asarray(nodes_value)   #este array contiene los valores para cada nodo
    if outputfile is None:
        np.save("node_values_{}_timestep{}".format(variable, instant), nodes_value)
        outfile = "node_values_{}_timestep{}.npy".format(variable, instant)
    else:
        np.save(outputfile, nodes_value)
        outfile = outputfile+".npy"
    return outfile



def interpolate_value(point, mesh2d, nodes_values):
    """
    This function assign a value to a given 2D point (z=0) within an 2D-essentially mesh (z=0).
    The assignment is based on a convex linear combination where the coefficients are the point
    barycentric coordinates and the values are those associated to the nodes of the corresponding triangle that
    contains the point

    :param point: array of dim(1,3) with last component z=0. Must be located inside the mesh!!
    :param mesh2d: trimesh triangular mesh object projected onto z=0 (all nodes must have z=0 component)
    :param nodes_values: array of dim(Nnodes,) of values associated to the mesh2d nodes
    :return:
    """
    _, _, face_index = trimesh.proximity.closest_point(mesh2d, point)   # get the face_index where the point is located
    face_nodes = mesh2d.faces[face_index[0]]   # get the nodes index of the face
    node0_index = face_nodes[0]
    node1_index = face_nodes[1]
    node2_index = face_nodes[2]
    node0coordinates = mesh2d.vertices[node0_index]     # get cartesian coordinates of node0
    node1coordinates = mesh2d.vertices[node1_index]     # get cartesian coordinates of node1
    node2coordinates = mesh2d.vertices[node2_index]     # get cartesian coordinates of node2

    # Barycentric coordinates are invariants under plane-projections
    point = point[0][:-1]                       # remove last component
    node0coordinates = node0coordinates[:-1]    # remove last component
    node1coordinates = node1coordinates[:-1]    # remove last component
    node2coordinates = node2coordinates[:-1]    # remove last component
    bar_coord = getBarycentricCoord(point, node0coordinates, node1coordinates, node2coordinates)

    v0 = nodes_values[node0_index]      # get the associated value to the node0
    v1 = nodes_values[node1_index]      # get the associated value to the node1
    v2 = nodes_values[node2_index]      # get the associated value to the node2
    interpolated_value = bar_coord[0]*v0 + bar_coord[1]*v1 + bar_coord[2]*v2

    return interpolated_value







"""PRIMERA PARTE QUE GUARDA LOS VALORES PONDERAODS EN LOS NODOS"""
#path2SeissolOutput = 'seissol_files/hdf5_float/Fra_v4_noWL_hdf5_float_2.5s_50s-surface.xdmf'
#variable = "u1"
#instant = 1
#outputfile = r"C:\Users\Alex\PycharmProjects\curso_python\temp"
#outfile = assign_nodes_values(path2SeissolOutput, variable, instant)
#print(outfile)
#outfile = "node_values_u1_timestep1.npy"
#valores_nodos = np.load(outfile)


"""SEGUNDA PARTE QUE ASIGNA UN VALOR A UN PUNTO CUALQUIERA DENTRO DE LA MALLA TRIANGULAR 2D"""
#punto = np.array([[-30647.46043395,  66107.62537402,   0.0]])
#mesh2d = generateMesh2DfromSeissol(path2SeissolOutput)
#a = interpolate_value(punto, mesh2d, valores_nodos)
#print(a)


"""
Solo quedaria iterar sobre un conjunto de puntos dados para interpolar y generar una
malla rectangular formada por los valores {(punto,valor_interpolado)}
"""





path2SeissolOutput = 'seissol_files/hdf5_float/Fra_v4_noWL_hdf5_float_2.5s_50s-surface.xdmf'
valores_nodos = np.load("node_values_u1_timestep1.npy")

punto = np.array([[-30647.46043395,  66107.62537402,   -1.0]])
mesh2d = generateMesh2DfromSeissol(path2SeissolOutput)

start_time = time.time()
rays = trimesh.ray.ray_pyembree.RayMeshIntersector(mesh2d) #ESTA ES LA BUENA!!!
a = rays.intersects_first(punto, np.array([[0., 0., 1.]]))
print(a)
print(time.time() - start_time)

#start_time = time.time()
#_, _, face_index = trimesh.proximity.closest_point(mesh2d, punto)   # get the face_index where the point is located
#print(time.time() - start_time)











































"""Esto define la malla rectangular"""
#x=np.arange(xmin,xmax,1000.0)
#y=np.arange(ymin,ymax,1000.0)
#X, Y = np.meshgrid(x,y)



#for i in range(0,N_nodos):
#for i in range(0,4):
#    celdas_conectadas = []
#    for k in range(0,N_celdas):
#        if i in connect[k]:
#            celdas_conectadas.append(k)
#    print("Los triangulos conectados al nodo {} son {}".format(i,celdas_conectadas))
#    area=0
#    valor=0
#    for j in celdas_conectadas:
#        area_j = dic_areas[j]
#        valor_j = ____[j]
#        area += area_j
#        valor+= valor_j*area_j
#    valor=valor/area



#geomX, geomY = np.meshgrid(geomx, geomy)
#print(geomX)
#pts_grosera_inicial = np.array(list(itertools.product(G.x,G.y)))
#ptos_grosera_rect = pts_grosera_inicial[in_rect]    #Puntos de la grosera dentro del rectangulo (por columnas)
#valores_grosera_rect = G.Z.T.flatten()[in_rect]     #Valores de la grosera dentro del rectangulo (por columnas)
#
#
#ZZc = griddata(ptos_grosera_rect, valores_grosera_rect, (X, Y), 'linear')


